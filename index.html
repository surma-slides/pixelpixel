<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
  <style>
  	.thank-you-slide article + p > span {
  		display: inline-block;
  		width: 115px;
  	}
  	.thank-you-slide article + p > a {
  		color: white;
  		border-bottom: none;
  	}
  	slides > slide:not(.nobackground):before {
  		content: attr(data-hashtag) !important;
  	}
    .huge {
        display: block;
    }
    .huge li:before {
        content: '→ ';
        color: rgba(255,0,0,0.5);
    }
    .huge li {
        font-size: 48px;
        line-height: 2em;
    }
    .small {
        font-size: 0.5em;
    }
  </style>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="logoslide nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/google_developers_logo.png"></span>
    </article>
  </slide>

  <slide class="title-slide segue nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1>Go Beginner’s Course</h1>
      <h2>Rapid Fire</h2>
      <p>
      	Alexander “surma” Surma<br>
      	nuboLAB, GDG Berlin Golang, OpenTechSchool<br>
      	2013-11-01
      </p>
    </hgroup>
  </slide>
<slide>
    <hgroup>
        <h2>Too fast?</h2>
        <h3>…it’s stolen, anyways.</h3>
    </hgroup>
    <article>
        <p>
            This introduction is heavily based on
            <ul>
                <li><a href="http://learnxinyminutes.com/docs/go/">Learn X in Y minutes, where X=Go</a> by <a href="https://github.com/soniakeys">Sonia Keys</a></li>
                <li><a href="https://gobyexample.com/">Go by Example</a> by <a href="https://github.com/mmcgrana">Mark McGranaghan</a></li>
            </ul>
        </p>
        <p>
            If you ever lose track or want to look something up — go to these sites. You
            can also find this presentation at <a href="http://surma-slides.github.com/pixelpixel">surma-slides.github.com/pixelpixel</a>.
        </p>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Requirements</h2>
    </hgroup>
    <article>
        <p>
            During introduction:
            <ul>
                <li>Programming experience</li>
                <li>Optional: <a href="http://play.golang.org">play.golang.org</a></li>
            </ul>
        </p>
        <p>
            During workshop:
            <ul>
                <li>Modern browser</li>
                <li>Editor</li>
                <li>Command-Line with <a href="http://github.com/voxelbrain/pixelpixel">picli</a></li>
            </ul>
        </p>
    </article>
</slide>
<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Ready?</h2>
        <h3>… go</h3>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Single line comment
/* Multi-
   line comment */
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// A “package” clause starts every source file.
// “main” is a special package name declaring an executable
// rather than a library.
package main
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
package main

// Import declaration declares library packages referenced in this file.
import (
    "fmt"      // A package in the Go standard library
    "net/http" // Yes, a web server!
    "strconv"  // String conversions
)
        </pre>
    </article>
    <aside class="note">
        <section>
            Yes, Go will punch you if you have unused imports. Get used to it.
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
package main

import (
    "fmt"
)

// A function definition.  Main is special.  It is the entry point for the
// executable program.  Love it or hate it, Go uses brace brackets.
func main() {
    // Println outputs a line to stdout.
    fmt.Println("Hello world!")

    // Call another function within this package.
    beyondHello()
}

        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>UTF8</li>
                <li>No semicoli</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Functions have parameters in parentheses.
// If there are no parameters, empty parentheses are still required.
func beyondHello() {
    var x int // Variable declaration.  Variables must be declared before use.
    x = 3     // Variable assignment.
    // “Short” declarations use := to infer the type, declare, and assign.
    y := 4
    sum, prod := learnMultiple(x, y)        // function returns two values
    fmt.Println("sum:", sum, "prod:", prod)
    learnTypes()
}

// Functions can have parameters and (multiple!) return values.
func learnMultiple(x, y int) (sum, prod int) {
    return x + y, x * y // return two values
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>“Before use” vs. “Head of function”</li>
                <li>Inference</li>
                <li><code>printf</code></li>
                <li>Type signature backwards? Think about typedefs.</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="go">
func learnTypes() {
    f := 3.14195 // float64, an IEEE-754 64-bit floating point number
    c := 3 + 4i  // complex128, represented internally with two float64s

    // Arrays have size fixed at compile time.
    var a4 [4]int           // an array of 4 ints, initialized to all 0
    a3 := [...]int{3, 1, 5} // an array of 3 ints, initialized as shown

    // Slices have dynamic size.  Arrays and slices each have advantages
    // but use cases for slices are much more common.
    s3 := []int{4, 5, 9}    // compare to a3.  no ellipsis here
    s4 := make([]int, 4)    // allocates slice of 4 ints, initialized to all 0
    bs := []byte("a slice") // type conversion syntax

    // Maps are a dynamically growable associative array type, like the
    // hash or dictionary types of some other languages.
    m := map[string]int{"three": 3, "four": 4}

    // …
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Zero-Value</li>
                <li><code>make</code> is magic</li>
                <li>This won’t compile, unused variables</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnTypes() {
    // …

    // Unused variables are an error in Go.
    // The underbar lets you “use” a variable but discard its value.
    _, _, _, _, _, _, _, _, _ = s2, g, f, u, pi, n, a3, s4, bs

    learnMemory()
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Annoying? Only when prototyping.</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnMemory() {
    p, q := useMemory() // declares p, q to be type pointer to int.
    fmt.Println(*p, *q) // * follows a pointer.  This prints two ints.

    learnFlowControl()
}

// Go is fully garbage collected.  It has pointers but no pointer arithmetic.
// You can make a mistake with a nil pointer, but not by incrementing a pointer.
func useMemory() (*int, *int) {
    s := make([]int, 20) // allocate 20 ints as a single block of memory
    s[3] = 7             // assign one of them
    r := -2              // declare another local variable
    return &s[3], &r     // & takes the address of an object.
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Compiler proves, if allocation is safe on stack</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // If statements require brace brackets, and do not require parens.
    // Formatting is standardized by the command line command “go fmt.”
    if false {
        // pout
    } else {
        // gloat
    }

    // …
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // Use switch in preference to chained if statements.
    x := 1
    switch x {
    case 0:
    case 1:
        // cases don't “fall through”
    case 2:
        // unreached
    }
    // …
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Explicit fallthrough</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // Like if, for doesn't use parens either.
    for x := 0; x < 3; x++ { // ++ is a statement
        fmt.Println("iteration", x)
    }

    // For is the only loop statement in Go, but it has alternate forms.
    for { // infinite loop
        break    // just kidding
        continue // unreached
    }
    // …
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li><code>x++</code> is a statement</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // As with for, := in an if statement means to declare and assign y first,
    // then test y > x.
    if y := expensiveComputation(); y > x {
        x = y
    }

    // …
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // Function literals are closures.
    xBig := func() bool {
        return x > 100 // references x declared in above switch statement.
    }
    x = 1e6
    fmt.Println("xBig:", xBig()) // true
    x /= 1e5                     // this makes x == 10
    fmt.Println("xBig:", xBig()) // false now

    learnInterfaces()
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Define Stringer as an interface type with one method, String.
type Stringer interface {
    String() string
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Define pair as a struct with two fields, ints named x and y.
type pair struct {
    x, y int
}

// Define a method on type pair.  Pair now implements Stringer.
func (p pair) String() string { // p is called the “receiver”
    // Sprintf is another public function in package fmt.
    // Dot syntax references fields of p.
    return fmt.Sprintf("(%d, %d)", p.x, p.y)
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>There’s no <code>-&gt;</code> notation</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnInterfaces() {
    // Brace syntax is a “struct literal.”  It evaluates to an initialized
    // struct.  The := syntax declares and initializes p to this struct.
    p := pair{3, 4}
    fmt.Println(p.String()) // call String method of p, of type pair.
    var i Stringer          // declare i of interface type Stringer.
    i = p                   // valid because pair implements Stringer
    fmt.Println(i.String())

    // Functions in the fmt package call the String method to ask an object
    // for a printable representation of itself.
    fmt.Println(p) // output same as above. Println calls String method.
    fmt.Println(i) // output same as above

    learnErrorHandling()
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnErrorHandling() {
    // “, ok” idiom used to tell if something worked or not.
    m := map[int]string{3: "three", 4: "four"}
    if x, ok := m[1]; !ok { // ok will be false because 1 is not in the map.
        fmt.Println("no one there")
    } else {
        fmt.Print(x) // x would be the value, if it were in the map.
    }
    // An error value communicates not just “ok” but more about the problem.
    if _, err := strconv.Atoi("non-int"); err != nil { // _ discards value
        // prints “strconv.ParseInt: parsing "non-int": invalid syntax”
        fmt.Println(err)
    }
    learnConcurrency()
}

        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="go">
// c is a channel, a concurrency-safe communication object.
func inc(i int, c chan int) {
    c <- i + 1 // <- is the "send" operator when a channel appears on the left.
}

func learnConcurrency() {
    // Same make function used earlier to make a slice.  Make allocates and
    // initializes slices, maps, and channels.
    c := make(chan int)
    // Start three concurrent goroutines.  Numbers will be incremented
    // concurrently, perhaps in parallel if the machine is capable and
    // properly configured.  All three send to the same channel.
    go inc(0, c) // go is a statement that starts a new goroutine.
    go inc(10, c)
    go inc(-805, c)
    // Read three results from the channel and print them out.
    // There is no telling in what order the results will arrive!
    fmt.Println(<-c, <-c, <-c) // channel on right, <- is "receive" operator.

    learnMoreConcurrency()
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Channels preserve order, but no telling which goroutine runs first.</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="go">
func learnMoreConcurrency() {
    c, cs, cc := make(chan int), make(chan string), make(chan chan string)
    go func() { c <- 84 }()       // start a new goroutine just to send a value
    go func() { cs <- "wordy" }() // again, for cs this time
    // Select selects a case at random out of the cases
    // that are ready to communicate.
    select {
    case i := <-c: // the value received can be assigned to a variable
        fmt.Printf("it's a %T", i)
    case <-cs: // or the value received can be discarded
        fmt.Println("it's a string")
    case <-cc: // usused channel, not ready for communication.
        fmt.Println("didn't happen.")
    }
    // At this point, one of the two goroutines started above has completed,
    // the other will remain blocked.
}
        </pre>
    </article>
</slide>
<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>pixel²</h2>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-pp.png" class="reflect">
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>A pixel made of pixels (256px × 256px)</li>
                <li>Drawable and clickable, each backed by a Go program</li>
                <li>Everyone gets a pixel for her-/himself</li>
                <li>Everyone can open this page</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-pplogs.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-ppcode.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-ppfirst.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Picli</h2>
    </hgroup>
    <article>
        To get started, you only need <code>picli</code> installed.
        <ul>
            <li>Go to <a href="http://github.com/voxelbrain/pixelpixel">pixelpixel’s GitHub page</a></li>
            <li>Download the binary for your platform listed in the README</li>
            <li>Put it in your <code>$PATH</code></li>
        </ul>

        If you are one of the eager students and have (or going to have) the
        go toolchain installed, you can do:

        <pre class="prettyprint" data-lang="bash">
            go get github.com/voxelbrain/pixelpixel/picli
        </pre>
    </article>
</slide>



  <slide class="thank-you-slide segue nobackground">
    <aside class="gdbar right"><img src="images/google_developers_icon_128.png"></aside>
    <article class="flexbox vleft auto-fadein">
      <h2>&lt;Thank You!&gt;</h2>
      <p>Questions?</p>
    </article>
	    <p class="auto-fadein">
	      <span>email</span><a href="mailto:surma@opentechschool.org">surma@opentechschool.org</a><br>
	      <span>g+</span><a href="http://plus.google.com/+AlexanderSurma">+AlexanderSurma</a><br>
	      <span>twitter</span><a href="http://twitter.com/surmair">surmair</a><br>
          <span>github</span><a href="http://github.com/surma">surma</a><br>
	    </p>
  </slide>

  <slide class="logoslide dark nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/google_developers_logo_white.png"></span>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>


<script>
	var slides = document.querySelectorAll("slides > slide:not(.nobackground)");
	for(var i in slides) {
		if(slides[i].setAttribute) {
			slides[i].setAttribute('data-hashtag', '#pixelpixel');
		}
	}
</script>
<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
